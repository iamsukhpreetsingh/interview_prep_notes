Normalization in database?

- It is the process of reducing redundancy, avoid anomalies, and ensure data integrity in databases by designing the database in such a way that no or very minimal bad data can enter in our database
1. Redundancy (Duplicate Data) - if a student address is stored in 3 different places/tables in database which lead to wastage of storage, cause inconsistencies and make the updation of data difficult.
2. Anomalies (Problems in Insert, Update, Delete) - Anomalies are unexpected errors/problems that occur when a database is not properly structured.
	- You cannot insert data because other unnecessary data is required. - insert 
	- Updating a customer’s phone number in one table but forgetting to update it in other tables. - update
	- Deleting the last student enrolled in a course also deletes the course information. - delete
		
3. Data integrity - data must be same and consistent everywhere in database. e.g. If "Sukhpreet Singh" is stored with the same spelling and same ID everywhere, that’s data integrity.


Normal Forms:
- In simple terms, NF are the safety levels/gurantees that ensure the data in the database is not redundant, no anomalies is there and integrity is maintained.

1. 1NF (1st Normal Form)
	- Each column contains atomic (indivisible) values
	  example:
	  #2323/3B1, Mohali, Punjab, India - Not 1NF
	  This is address column. But we can divide it into 3 atomic columns i.e. Apparment, State, and Country. This is 1NF.
	- Each row contain values of same type.
	- Each row is unique (ensured by a PK). 
	- No repeating group of columns.
2. 2NF (2nd Normal Form)
	- It must be in 1NF.
	- All non-key attribute must be fully functionally dependent on entire PK. Means no non-key column should depend on only part of primary key.
		- i.e. NO partial dependencies on PK.
	
	Example:
	CREATE TABLE book_orders_1nf (
	    order_id INT,
	    book_isbn VARCHAR(20),
	    customer_name VARCHAR(100),
	    customer_email VARCHAR(100),
	    customer_address VARCHAR(255),
	    book_title VARCHAR(200),
	    book_author VARCHAR(100),
	    book_price DECIMAL(10, 2),
	    order_date DATE,
	    quantity INT,
	    total_price DECIMAL(10, 2),
	    PRIMARY KEY (order_id, book_isbn)
	);
	
	like customer_name, customer_address, customer_email is dependening on order_id(PK), not on book_isbn.
	similarly book_title, book_author, book_price is depending on book_isbn(PK), not on order_id.
	These 2 are depending on part of PK. Not Entire PK, means they are partially dependent, and this is the thing we remove in 2NF. which does'nt comply with 2NF rule.
	
	So 2NF tables will be:
	
	CREATE TABLE orders_2nf (
	    order_id INT PRIMARY KEY,
	    customer_name VARCHAR(100),
	    customer_email VARCHAR(100),
	    customer_address VARCHAR(255),
	    order_date DATE
	);

	CREATE TABLE books_2nf (
	    isbn VARCHAR(20) PRIMARY KEY,
	    title VARCHAR(200),
	    author VARCHAR(100),
	    price DECIMAL(10, 2)
	);

	CREATE TABLE order_items_2nf (
	    order_id INT,
	    book_isbn VARCHAR(20),
	    quantity INT,
	    total_price DECIMAL(10, 2),
	    PRIMARY KEY (order_id, book_isbn),
	    FOREIGN KEY (order_id) REFERENCES orders_2nf(order_id),
	    FOREIGN KEY (book_isbn) REFERENCES books_2nf(isbn)
	);
	
3. 3NF (3rd Normal Form):
	- It must be in 2NF
	- It must not have transitive dependencies. i.e. a non key attribute depend on another non-key attribute, rather than depending on PK.
	
	Example:
	CREATE TABLE orders_2nf (
	    order_id INT PRIMARY KEY,
	    customer_name VARCHAR(100),
	    customer_email VARCHAR(100),
	    customer_address VARCHAR(255),
	    order_date DATE
	);
	
	like customer_email, customer_address depends on customer_name not on PK order_id. So one non key attribute is depending on another non key attribute. So, what we will do is seprate customers and orders data into seperate tables.
	
	CREATE TABLE customers_3nf (
	    customer_id INT AUTO_INCREMENT PRIMARY KEY,
	    name VARCHAR(100),
	    email VARCHAR(100),
	    address VARCHAR(255)
	);

	CREATE TABLE orders_3nf (
	    order_id INT PRIMARY KEY,
	    customer_id INT,
	    order_date DATE,
	    FOREIGN KEY (customer_id) REFERENCES customers_3nf(customer_id)
	);

	CREATE TABLE books_3nf (
	    isbn VARCHAR(20) PRIMARY KEY,
	    title VARCHAR(200),
	    author VARCHAR(100),
	    price DECIMAL(10, 2)
	);

	CREATE TABLE order_items_3nf (
	    order_id INT,
	    book_isbn VARCHAR(20),
	    quantity INT,
	    PRIMARY KEY (order_id, book_isbn),
	    FOREIGN KEY (order_id) REFERENCES orders_3nf(order_id),
	    FOREIGN KEY (book_isbn) REFERENCES books_3nf(isbn)
	);
	
	
	
Disadvantages of Normalization
1. More Tables → More Joins → Slower Queries
2. Harder for Reporting & Analytics
3. More Foreign Keys → Slower Insert/Update
4. Complex Queries
